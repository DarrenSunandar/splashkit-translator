<%#
    Strings from a std::string in the SK code must be allocated on heap and
    freed after use. An example would be:

    1. SK function `Foo' returns a `std::string'
    2. Wrap `std::string' as `__sklib_string'
    3. Return `__sklib_string'
    4. Language `Bar' calls Lib function `Foo' returning the `__sklib_string'
    5. Wrap the returned `__sklib_string''s underlying `char*` in `Bar::String'
    6. Free the returned `__sklib_string' from the heap
    7. Return the wrapped `Bar::String'
%>
typedef struct {
  char *string;
  int size;
} __sklib_string;
__sklib_string __skadapter__to_sklib_string(std::string s) {
    __sklib_string result;
    result.size = s.length();
    result.string = (char *)malloc(result.size + 1);
    strcpy(result.string, s.c_str());
    return result;
}
void __skadapter__free_sklib_string(__sklib_string s) {
    free(s.string);
}
std::string __skadapter__to_string(__sklib_string s) {
    return std::string(s.string);
}

<%#
    SK `bool' to C `int' adapter macros.
%>
#define __skadapter__to_sklib_bool(value)\
(value == true ? 1 : 0)
#define __skadapter__to_bool(value)\
(value == 1 ? true : false)

<%#
    Direct adapters are made for no change between SK and Lib types. Use the
    `__skadapter__make_direct_adapter' macro to generate adapter methods for a
    no-change type.
%>
#define __skadapter__make_direct_adapter(type)\
type __skadapter__to_sklib_##type(type value) { return value; }\
type __skadapter__to_##type(type value) { return value; }
<% @no_type_changes.each do |type| %>
__skadapter__make_direct_adapter(<%= type %>)
<% end %>

<%#
    `__sklib_ptr' is a wrapper for typealiases to pointer types using static
    casts. Use the `__skadapter__make_typealias_adapter' macro to make adapter
    functions to and from the SK and Lib pointer typealiases.
 %>
#define __sklib_ptr void *
#define __skadapter__make_typealias_adapter(type)\
__sklib_ptr __skadapter__to_sklib_##type(type value) { return static_cast<__sklib_ptr>(value); }\
type __skadapter__to_##type(__sklib_ptr value) { return static_cast<type>(value); }
<% @typealiases.each do |typealias| %>
__skadapter__make_typealias_adapter(<%= typealias[:name] %>)
<% end %>

<%#
    Enums are converted to their integer representations using static casts.
    Use the `__skadapter__make_enum_adapter' macro to make adapter functions to
    and from the SK and Lib enums.
 %>
#define __skadapter__make_enum_adapter(type)\
int __skadapter__to_sklib_##type(type value) { return static_cast<int>(value); }\
type __skadapter__to_##type(int value) { return static_cast<type>(value); }
<% @enums.each do |enum| %>
__skadapter__make_typealias_adapter(<%= enum[:name] %>)
<% end %>

<%#
    Structs must have each field converted to a compatible Lib type (i.e., the
    field type `foo' becomes `__sklib_foo'). Then adapters must be made to and
    from the Lib and SK code. Can't use a macro for this and cannot be a static
    cast so we must generate the functions individually.
 %>
<% @structs.each do |struct| %>
typedef struct
{
<% struct[:fields].each do |field_name, field_data| %>
    __sklib_<%= field_data[:type] %> <%= field_name %>
<% end %>
} __sklib_<%= struct[:name] %>;
__sklib_<%= struct[:name] %> __skadapter__to_sklib_<%= struct[:name] %>(<%= struct[:name] %> v)
{
    __sklib_<%= struct[:name] %> __sklib_return_value;
<% struct[:fields].each do |field_name, field_data| %>
    v.<%= field_name %> = __skadapter__to_sklib_<%= field_data[:type] %>(v.<%= field_name %>);
<% end %>
    return __sklib_return_value;
}
<%= struct[:name] %> __skadapter__to_<%= struct[:name] %>(__sklib_<%= struct[:name] %> v)
{
    <%= struct[:name] %> __sklib_return_value;
<% struct[:fields].each do |field_name, field_data| %>
    v.<%= field_name %> = __skadapter__to_<%= field_data[:type] %>(v.<%= field_name %>);
<% end %>
    return __sklib_return_value;
}

<% end %>
