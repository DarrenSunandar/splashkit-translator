<%#
    Strings from a std::string in the SK code must be allocated on heap and
    freed after use. An example would be:

    1. SK function `Foo' returns a `std::string'
    2. Wrap `std::string' as `__sklib_string'
    3. Return `__sklib_string'
    4. Language `Bar' calls Lib function `Foo' returning the `__sklib_string'
    5. Wrap the returned `__sklib_string''s underlying `char*` in `Bar::String'
    6. Free the returned `__sklib_string' from the heap
    7. Return the wrapped `Bar::String'
%>
typedef struct
{
  char *string;
  int size;
} __sklib_string;
__sklib_string <%= func_prefix %>__to_sklib_string(const std::string &s)
{
    __sklib_string __skreturn;
    __skreturn.size = (int)s.length();
    __skreturn.string = (char *)malloc(__skreturn.size + 1);
    strcpy(__skreturn.string, s.c_str());
    return __skreturn;
}
void <%= func_prefix %>__free__sklib_string(__sklib_string s)
{
<%
    # This call effectively does nothing if the translator using this template
    # should not free heap memory (i.e., C++ using C template)
    unless free_heap_allocated?
%>
    <%= CLib::FUNC_PREFIX %>__free__sklib_string(s);
<%
    else
%>
    free(s.string);
<%
    end # end unless
%>
}
std::string <%= func_prefix %>__to_string(const __sklib_string &s)
{
    std:string result = std::string(s.string);
    __skadapter__free__sklib_string(s);
    return result;
}
